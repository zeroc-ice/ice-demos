// Copyright (c) ZeroC, Inc.

package com.example.ice.secure.client;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;

import com.example.visitorcenter.GreeterPrx;
import com.zeroc.Ice.Communicator;
import com.zeroc.Ice.Util;

class Client {
    public static void main(String[] args) {
        var initData = new com.zeroc.Ice.InitializationData();
        initData.properties = new com.zeroc.Ice.Properties(args);

        // Create the SSLContext and use it to configure the communicator. When the communicator establishes a new
        // outgoing ssl connection, it uses the `clientSSLEngineFactory` to create a SSLEngine for that connection.
        // Here, we generate these SSLEngine instances using our carefully crafted SSLContext.
        SSLContext sslContext = createSSLContext();
        initData.clientSSLEngineFactory =
            (String peerHost, int peerPort) -> sslContext.createSSLEngine(peerHost, peerPort);

        // Create an Ice communicator. We'll use this communicator to create proxies and manage outgoing connections.
        try (Communicator communicator = Util.initialize(initData)) {
            // GreeterPrx is a class generated by the Slice compiler. We create a proxy from a communicator and a
            // "stringified proxy" with the address of the target object.
            GreeterPrx greeter = GreeterPrx.createProxy(communicator, "greeter:ssl -h localhost -p 4061");

            // Send a request to the remote object and get the response.
            String greeting = greeter.greet(System.getProperty("user.name"));
            System.out.println(greeting);
        }
    }

    /**
     * Creates and initializes an SSLContext for use with the ssl transport.
     *
     * <p>The SSLContext is configured with the demo CA certificate loaded from a PKCS12 keystore,
     * which is used as the trust store to validate server certificates.
     *
     * @return the initialized SSLContext
     * @throws RuntimeException if an error occurs during SSL initialization
     */
    private static SSLContext createSSLContext() {
        try {
            SSLContext sslContext = SSLContext.getInstance("TLS");
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            String keyStorePath = "../../../../certs/ca.p12";

            // The password for the PKCS12 keystore, hard-coded for simplicity.
            // In a production environment, use a secure method to store and retrieve this password.
            char[] password = "password".toCharArray();

            try (var input = new FileInputStream(keyStorePath)) {
                keyStore.load(input, password);
            }
            TrustManagerFactory trustManagerFactory =
                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(keyStore);
            sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
            return sslContext;
        } catch (
            CertificateException
                | IOException
                | KeyManagementException
                | KeyStoreException
                | NoSuchAlgorithmException ex) {
            // Should never happen in this demo.
            throw new RuntimeException("SSL initialization error.", ex);
        }
    }
}
