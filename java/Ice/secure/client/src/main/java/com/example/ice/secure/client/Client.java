// Copyright (c) ZeroC, Inc.

package com.example.ice.secure.client;

import com.example.visitorcenter.GreeterPrx;
import com.zeroc.Ice.Communicator;
import com.zeroc.Ice.Util;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import java.io.FileInputStream;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;

class Client {
    public static void main(String[] args) {

        // The password for the PKCS12 keystore, hard-coded for simplicity.
        // In a production environment, use a secure method to store and retrieve this password.
        char[] password = "password".toCharArray();

        // Create a KeyStore object to load the CA's certificate.
        // The PKCS12 format is recommended for modern Java applications.
        KeyStore keyStore;
        try {
            keyStore = KeyStore.getInstance("PKCS12");
        } catch (KeyStoreException ex) {
            throw new RuntimeException("Error initializing PKCS12 keystore.", ex);
        }

        // Load the CA certificate from the keystore file into the KeyStore object.
        String keyStorePath = "../../../../certs/cacert.p12";
        try (var input = new FileInputStream(keyStorePath)) {
            keyStore.load(input, password);
        } catch (Exception ex) {
            throw new RuntimeException("Error loading keystore.", ex);
        }

        // Create a TrustManagerFactory to manage the trusted certificates.
        // This will be used by the SSLContext to verify that the server's certificate was signed by our demo
        // custom CA.
        TrustManagerFactory trustManagerFactory;
        try {
            trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(keyStore);
        } catch (Exception ex) {
            throw new RuntimeException("Error initializing key manager factory.", ex);
        }

        // Create an SSLContext using the TLS protocol.
        SSLContext sslContext;
        try {
            sslContext = SSLContext.getInstance("TLS");
        } catch (NoSuchAlgorithmException ex) {
            throw new RuntimeException("Error initializing TLS protocol.", ex);
        }

        // Initialize the SSLContext with the trust managers from the TrustManagerFactory.
        try {
            sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
        } catch (Exception ex) {
            throw new RuntimeException("Error initializing SSL context.", ex);
        }

        var initData = new com.zeroc.Ice.InitializationData();
        initData.properties = new com.zeroc.Ice.Properties(args);
        
        // The clientSSLEngineFactory lambda provides the communicator with an SSLEngine that uses our custom
        // SSLContext for each outgoing secure connection.
        initData.clientSSLEngineFactory =
            (String peerHost, int peerPort) -> sslContext.createSSLEngine(peerHost, peerPort);

        // Create an Ice communicator. We'll use this communicator to create proxies and manage outgoing connections.
        try (Communicator communicator = Util.initialize(initData)) {
            // GreeterPrx is a class generated by the Slice compiler. We create a proxy from a communicator and a
            // "stringified proxy" with the address of the target object.
            // If you run the server on a different computer, replace localhost in the string below with the server's
            // hostname or IP address.
            GreeterPrx greeter = GreeterPrx.createProxy(communicator, "greeter:ssl -h localhost -p 4061");

            // Send a request to the remote object and get the response.
            String greeting = greeter.greet(System.getProperty("user.name"));
            System.out.println(greeting);

            // Send another request to the remote object, this time with greetAsync.
            // 'greetAsync' returns a future immediately.
            CompletableFuture<String> futureGreeting = greeter.greetAsync("alice");

            try {
                greeting = futureGreeting.get();
                System.out.println(greeting);
            } catch (InterruptedException e) {
                assert false; // We don't interrupt this thread.
            } catch (ExecutionException e) {
                System.out.println("Could not get greeting: " + e.getMessage());
            }
        }
    }
}
