# Copyright (c) ZeroC, Inc.

from EarlyRiser import AlarmClock, ButtonPressed
import asyncio
import Ice

class MockAlarmClock(AlarmClock):
    """
    MockAlarmClock is an Ice servant that implements Slice interface AlarmClock.
    """

    def __init__(self, eventLoop):
        self._needMoreTime = True
        self._stopPressed = eventLoop.create_future()

    async def waitForStopPressed(self) -> None:
        """
        Asynchronously wait for the ring method to return ButtonPressed.Stop.
        """
        await self._stopPressed

    async def ring(self, message: str, current: Ice.Current) -> ButtonPressed:
        """
        Implements the abstract method ring from the AlarmClock class generated by the Slice compiler.

        Parameters
        ----------
        message : str
            The message to display on the alarm clock.
        current : Ice.Current
            The Current object for the dispatch.
        """

        print(f"Dispatching ring request {{ message = '{message}' }}")
        if self._needMoreTime:
            print(f"Returning {ButtonPressed.Snooze} to request more time.")
            self._needMoreTime = False # we only snooze one time
            return ButtonPressed.Snooze
        else:
            if not self._stopPressed.done():
                # We configured the Ice communicator to dispatch all async methods in the asyncio event loop.
                # Marking the _stopPressed future as done immediately would create a deadlock, because the caller
                # would continue and wait for this dispatch to complete. So we mark the future as done soon,
                # after this dispatch completes.
                asyncio.get_running_loop().call_soon(lambda: self._stopPressed.set_result(None))
            print(f"Returning {ButtonPressed.Stop} to stop the alarm.")
            return ButtonPressed.Stop
