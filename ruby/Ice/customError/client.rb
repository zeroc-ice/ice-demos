#!/usr/bin/env ruby
# Copyright (c) ZeroC, Inc.

require 'etc'
require 'Ice'

# Load the code generated by the Slice compiler. The Slice module VisitorCenter maps to a Ruby module with the same
# name.
require_relative 'Greeter.rb'

# Create an Ice communicator. We'll use this communicator to create proxies and manage outgoing connections.
Ice::initialize(ARGV) do |communicator|
    # GreeterPrx is a class generated by the Slice compiler. We create a proxy from a communicator and a "stringified
    # proxy" with the address of the target object. If you run the server on a different computer, replace localhost in
    # the string below with the server's hostname or IP address.
    greeter = VisitorCenter::GreeterPrx.new(communicator, "greeter:tcp -h localhost -p 4061")

    names =  [Etc.getlogin, "", "alice", "bob", "carol", "dave", "billy bob"]

    for name in names do
        # Send a request to the remote object and get the response. The response from the server can carry:
        # - a greeting (success)
        # - a dispatch exception (the base class for marshallable system exceptions), or
        # - a GreeterException (the custom exception we've defined in the Slice definitions)
        begin
            greeting = greeter.greet(name)
            puts greeting
        rescue Ice::DispatchException => exception
            # Converts exception.replyStatus to an Ice.ReplyStatus enumerator. This fails when
            # exception.replyStatus does not correspond to a known enumerator.
            replyStatus = Ice::ReplyStatus.from_int(exception.replyStatus)
            puts "Failed to create a greeting for '#{name}': DispatchException { message = '#{exception.message}', "\
                "replyStatus = #{replyStatus} }"
        rescue VisitorCenter::GreeterException => exception
            puts "Failed to create a greeting for '#{name}': GreeterException { errorMessage = "\
                "'#{exception.errorMessage}', error = #{exception.error} }"
        end
    end
end
